package com.bulbasaur.dat256.services.firebase;

import android.support.annotation.NonNull;

import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QuerySnapshot;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;


/**
 * @author ludwighultqvist
 * a class that implements the Collection interface
 */
class Collection implements DBCollection {

    private CollectionReference collection;

    /**
     * package private constructor that initializes the object with a reference to the
     * firebase-collection from the given root.
     * an instance should not be able to be directly created from outside the package
     * @param root the root string
     */
    Collection(String root) {
        this(FirebaseFirestore.getInstance().collection(root));
    }

    /**
     * package private constructor that initializes the object with a given reference to a
     * firebase-collection.
     * an instance should not be able to be directly created from outside the package
     * @param collection the CollectionReference object
     */
    Collection(CollectionReference collection) {
        this.collection = collection;
    }

    /**
     * creates a new document in the collection with a given id (should be generated)
     * @param id the given id string
     * @param listener the listener of the request
     * @return a new DBDocument object
     */
    @Override
    public DBDocument create(String id,@NonNull  RequestListener<DBDocument> listener) {
        DocumentReference reference = id == null ? collection.document() : collection.document(id);
        return new Document(reference, listener);
    }

    /**
     * creates a new document in the collection with an autogenerated id
     * @param listener the listener of the request
     * @return a new DBDocument object
     */
    @Override
    public DBDocument create(@NonNull RequestListener<DBDocument> listener) {
        return create(null, listener);
    }

    /**
     * fetches a document with the given id from the collection in the database.
     * if no document is found, null is returned
     * @param id the given id string
     * @param listener the listener of the request
     * @return the DBDocument found
     */
    @Override
    public DBDocument get(String id, @NonNull RequestListener<DBDocument> listener) {
        Document document = new Document();

        collection.document(id).get()
                .addOnCompleteListener(task -> {
                    if (task.isSuccessful()) {
                        DocumentSnapshot snapshot = task.getResult();
                        if (snapshot != null && snapshot.exists()) {
                            document.init(snapshot.getReference(), listener);
                        }
                        else {
                            listener.onComplete(document);
                        }
                    }
                    else {
                        listener.onComplete(document);
                    }
                })
                .addOnFailureListener(e -> listener.onFailure(document));

        return listener.getObject();
    }

    /**
     * fetches all documents from the collection in the database
     * @param listener the listener of the request
     * @return the list of documents
     */
    @Override
    public List<? extends DBDocument> all(@NonNull RequestListener<List<? extends DBDocument>> listener) {
        List<Document> documents = new ArrayList<>();

        collection.get()
                .addOnCompleteListener(task -> {
                    if (task.isSuccessful()) {
                        QuerySnapshot snapshot = task.getResult();
                        if (snapshot != null) {
                            for (DocumentSnapshot document : snapshot.getDocuments()) {
                                documents.add(new Document(document.getReference()));
                            }
                            listener.onSuccess(documents);
                        }
                        else {
                            listener.onComplete(documents);
                        }
                    }
                    else {
                        listener.onComplete(documents);
                    }
                })
                .addOnFailureListener(e -> listener.onFailure(documents));

        return listener.getObject();
    }


    @Override
    public List<? extends DBDocument> search(List<QueryFilter> filters, @NonNull RequestListener<List<? extends DBDocument>> listener) {
        Query query = collection;
        List<Document> documents = new ArrayList<>();

        for (QueryFilter filter : filters) {
            switch (filter.getComparison()) {
                case "=":
                    query = query.whereEqualTo(filter.getField(), filter.getValue());
                    break;
                case "<":
                    query = query.whereLessThan(filter.getField(), filter.getValue());
                    break;
                case ">":
                    query = query.whereGreaterThan(filter.getField(), filter.getValue());
                    break;
                default:
            }
        }

        query.get()
                .addOnCompleteListener(task -> {
                    if (task.isSuccessful()) {
                        QuerySnapshot snapshot = task.getResult();

                        if (snapshot != null) {
                            for (DocumentSnapshot document : snapshot.getDocuments()) {
                                documents.add(new Document(document.getReference()));
                            }
                            listener.onSuccess(documents);
                        }
                        else {
                            listener.onComplete(documents);
                        }
                    }
                    else {
                        listener.onComplete(documents);
                    }
                })
                .addOnFailureListener(e -> listener.onFailure(documents));

        return listener.getObject();
    }

    /**
     * searches the documents of the collection according to given filter and returns the documents
     * that matches
     * @param queryFilter the filter object
     * @param listener the listener of the request
     * @return the list of documents
     */
    @Override
    public List<? extends DBDocument> search(QueryFilter queryFilter, @NonNull RequestListener<List<? extends DBDocument>> listener) {
        Query query = collection;
        List<Document> documents = new ArrayList<>();

        Map<String, Object> filters = queryFilter.getFilters();
        for (String comparision : filters.keySet()) {
            Object value = filters.get(comparision);
            if (value == null) {
                continue;
            }

            switch (comparision) {
                case "=":
                    query = query.whereEqualTo(queryFilter.getField(), value);
                    break;
                case "<":
                    query = query.whereLessThan(queryFilter.getField(), value);
                    break;
                case ">":
                    query = query.whereGreaterThan(queryFilter.getField(), value);
                    break;
                default:
            }
        }

        query.get()
                .addOnCompleteListener(task -> {
                    if (task.isSuccessful()) {
                        QuerySnapshot snapshot = task.getResult();

                        if (snapshot != null) {
                            for (DocumentSnapshot document : snapshot.getDocuments()) {
                                documents.add(new Document(document.getReference()));
                            }
                            listener.onSuccess(documents);
                        }
                        else {
                            listener.onComplete(documents);
                        }
                    }
                    else {
                        listener.onComplete(documents);
                    }
                })
                .addOnFailureListener(e -> listener.onFailure(documents));


        return documents;
    }

    /**
     * creates and returns a runnable tester of the document.
     * @return the runnable object
     */
    @Override
    public Runnable tester() {
        return new Tester();
    }

    @NonNull
    @Override
    public String toString() {
        return "Collection: [" + "id: " + collection.getId() + ", " + "path: " + collection.getPath() + "]";
    }

    /**
     * private class used for running tests
     */
    private class Tester implements Runnable {
        private static final String ID = "test-collection";
        private Collection collection = Collection.this;

        /*
        System.out.println("\n---------- COLLECTION TEST STARTED ----------\n");

        System.out.println("initial state: " + this.toString());

        String id = "test-document-id";
        System.out.println("testing get...");
        String s = get(id) == null ? null : get(id).toString();
        System.out.println("get(" + id + ") -> " + s);
        System.out.println();

        System.out.println("testing create...");
        DBDocument d = create();
        d.save();
        System.out.println("create() -> " + d.toString());
        System.out.println();

        System.out.println("testing get...");
        System.out.println("get(" + d.id() + ") -> " + get(id).toString());
        d.delete();
        System.out.println();

        System.out.println("testing create(id)...");
        id = "test-document-custom-id";
        d = create(id);
        System.out.println("create(" + id + ") -> " + d.toString());
        System.out.println();

        System.out.println("testing get...");
        System.out.println("get(" + id + ") -> " + get(id).toString());
        d.delete();
        System.out.println();

        System.out.println("testing all...");
        System.out.print("all() -> " + all().toString());
        System.out.println();


        System.out.println("testing search...");
        System.out.print("NOT IMPLEMENTED");
        System.out.println();


        System.out.println("resetting...");
        System.out.println("final state: " + this.toString());

        System.out.println("\n---------- COLLECTION TEST FINISHED ----------\n");
        */

        /*
        1. get -> null
        2. create -> get
        4. create(id) -> get
        5. create multiple
        5. all
        6. search
        7. reset
        */

        /*
        test of the get method
         */
        private void get() {
        }

        /*
        test of the all method
         */
        private void all() {

        }

        /*
        test of the search method
         */
        private void search() {
        }

        /*
        reset the collection after the tests
         */
        private void reset() {

        }

        /**
         * method used to run all tests
         */
        @Override
        public void run() {
        }
    }
}
